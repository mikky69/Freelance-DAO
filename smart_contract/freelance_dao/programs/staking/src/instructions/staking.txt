for the staking program
instructions folder
admin.rs
use crate::{
    errors::StakingError,
    state_accounts::{RewardsConfig, StakePool},
};
use anchor_lang::prelude::*;

#[derive(Accounts)]
pub struct SetPoolParams<'info> {
    #[account(
        seeds = [b"rewards_config"],
        bump = rewards_config.bump,
        has_one = admin @ StakingError::Unauthorized
    )]
    pub rewards_config: Account<'info, RewardsConfig>,
    #[account(mut)]
    pub pool: Account<'info, StakePool>,
    pub admin: Signer<'info>,
}

#[derive(Accounts)]
pub struct SetRewardsParams<'info> {
    #[account(
        mut,
        seeds = [b"rewards_config"],
        bump = rewards_config.bump,
        has_one = admin @ StakingError::Unauthorized
    )]
    pub rewards_config: Account<'info, RewardsConfig>,
    pub admin: Signer<'info>,
}

pub fn set_pool_params(
    ctx: Context<SetPoolParams>,
    rate: Option<u64>,
    paused: Option<bool>,
) -> Result<()> {
    let pool = &mut ctx.accounts.pool;
    let clock = Clock::get()?;

    if let Some(new_rate) = rate {
        require!(new_rate > 0, StakingError::InvalidAmount);
        pool.points_per_token_per_second = new_rate;
    }

    if let Some(pause_state) = paused {
        pool.paused = pause_state;
    }

    // Emit event for tracking
    emit!(crate::events::PoolParamsUpdated {
        pool: pool.key(),
        new_rate: rate,
        paused,
        timestamp: clock.unix_timestamp,
    });

    Ok(())
}

pub fn set_rewards_params(
    ctx: Context<SetRewardsParams>,
    exchange_rate: Option<u64>,
    paused: Option<bool>,
) -> Result<()> {
    let rewards_config = &mut ctx.accounts.rewards_config;
    let clock = Clock::get()?;

    if let Some(new_rate) = exchange_rate {
        require!(new_rate > 0, StakingError::InvalidExchangeRate);
        rewards_config.exchange_rate = new_rate;
    }

    if let Some(pause_state) = paused {
        rewards_config.paused = pause_state;
    }

    // Emit event for tracking
    emit!(crate::events::RewardsParamsUpdated {
        new_exchange_rate: exchange_rate,
        paused,
        timestamp: clock.unix_timestamp,
    });

    Ok(())
}

init.rs
use crate::{
    events::{PoolInitialized, RewardsConfigInitialized},
    state_accounts::{RewardsConfig, StakePool},
};
use anchor_lang::prelude::*;
use anchor_spl::token::{Mint, Token, TokenAccount};

#[derive(Accounts)]
pub struct InitRewardsConfig<'info> {
    #[account(
        init,
        payer = admin,
        space = RewardsConfig::SPACE,
        seeds = [b"rewards_config"],
        bump
    )]
    pub rewards_config: Account<'info, RewardsConfig>,
    /// CHECK: This is the mint authority PDA
    #[account(
        seeds = [b"mint_authority"],
        bump
    )]
    pub mint_authority: UncheckedAccount<'info>,
    /// CHECK: This is the treasury PDA
    #[account(
        seeds = [b"treasury"],
        bump
    )]
    pub treasury: UncheckedAccount<'info>,
    #[account(mut)]
    pub admin: Signer<'info>,
    pub system_program: Program<'info, System>,
}

pub fn init_rewards_config(
    ctx: Context<InitRewardsConfig>,
    fl_dao_mint: Pubkey,
    exchange_rate: u64,
    admin: Pubkey,
) -> Result<()> {
    let rewards_config = &mut ctx.accounts.rewards_config;
    let clock = Clock::get()?;

    rewards_config.admin = admin;
    rewards_config.fl_dao_mint = fl_dao_mint;
    rewards_config.exchange_rate = exchange_rate;
    rewards_config.treasury = ctx.accounts.treasury.key();
    rewards_config.mint_authority = ctx.accounts.mint_authority.key();
    rewards_config.global_points_issued = 0;
    rewards_config.global_fldao_minted = 0;
    rewards_config.paused = false;
    rewards_config.bump = ctx.bumps.rewards_config;

    emit!(RewardsConfigInitialized {
        admin,
        fl_dao_mint,
        exchange_rate,
        timestamp: clock.unix_timestamp,
    });

    Ok(())
}

#[derive(Accounts)]
pub struct InitPool<'info> {
    #[account(
        init,
        payer = admin,
        space = StakePool::SPACE,
        seeds = [b"pool", mint.key().as_ref()],
        bump
    )]
    pub pool: Account<'info, StakePool>,
    #[account(
        init,
        payer = admin,
        token::mint = mint,
        token::authority = pool,
        seeds = [b"vault", mint.key().as_ref()],
        bump
    )]
    pub vault: Account<'info, TokenAccount>,
    pub mint: Account<'info, Mint>,
    #[account(mut)]
    pub admin: Signer<'info>,
    pub token_program: Program<'info, Token>,
    pub system_program: Program<'info, System>,
}

pub fn init_pool(
    ctx: Context<InitPool>,
    mint: Pubkey,
    is_lp: bool,
    points_per_token_per_second: u64,
    max_stake_per_user: u64, // ADD THIS PARAMETER
) -> Result<()> {
    let pool = &mut ctx.accounts.pool;
    let clock = Clock::get()?;

    pool.mint = mint;
    pool.vault = ctx.accounts.vault.key();
    pool.is_lp = is_lp;
    pool.points_per_token_per_second = points_per_token_per_second;
    pool.total_staked = 0;
    pool.total_points_issued = 0;
    pool.created_at = clock.unix_timestamp;
    pool.paused = false;
    pool.bump = ctx.bumps.pool;
    pool.max_stake_per_user = max_stake_per_user; // ADD THIS

    emit!(PoolInitialized {
        pool: pool.key(),
        mint,
        is_lp,
        points_per_token_per_second,
        timestamp: clock.unix_timestamp,
    });

    Ok(())
}

mod.rs
// programs/staking/src/instructions/mod.rs
pub mod init;
pub mod staking;
pub mod rewards;
pub mod admin;
pub mod utils;
pub mod query;  

pub use init::*;
pub use staking::*;
pub use rewards::*;
pub use admin::*;
pub use utils::*;
pub use query::*;

query
use anchor_lang::prelude::*;
use crate::state_accounts::StakePosition;
use crate::errors::StakingError;

#[derive(Accounts)]
pub struct GetPosition<'info> {
    #[account(
        seeds = [b"position", pool.key().as_ref(), staker.key().as_ref()],
        bump = position.bump
    )]
    pub position: Account<'info, StakePosition>,
    /// CHECK: Pool validation happens in position seeds
    pub pool: UncheckedAccount<'info>,
    pub staker: Signer<'info>,
}

pub fn get_position(ctx: Context<GetPosition>) -> Result<(u64, u128)> {
    let position = &ctx.accounts.position;
    Ok((position.amount, position.accum_points))
}

// View-only function for cross-program calls
#[derive(Accounts)]
pub struct ViewPosition<'info> {
    #[account(
        seeds = [b"position", pool.key().as_ref(), user.key().as_ref()],
        bump = position.bump
    )]
    pub position: Account<'info, StakePosition>,
    /// CHECK: Pool validation happens in position seeds
    pub pool: UncheckedAccount<'info>,
    /// CHECK: User key used in seeds
    pub user: UncheckedAccount<'info>,
}

pub fn view_position(ctx: Context<ViewPosition>) -> Result<u64> {
    Ok(ctx.accounts.position.amount)
}

rewards
// programs/staking/src/instructions/rewards.rs
use crate::{
    errors::StakingError,
    events::PointsExchanged,
    math::points_to_fldao,
    state_accounts::{RewardsConfig, StakePosition},
};
use anchor_lang::prelude::*;
use anchor_spl::token::{self, Mint, MintTo, Token, TokenAccount};

#[derive(Accounts)]
pub struct ExchangePoints<'info> {
    #[account(
        mut,
        seeds = [b"rewards_config"],
        bump = rewards_config.bump
    )]
    pub rewards_config: Account<'info, RewardsConfig>,
    #[account(
        mut,
        has_one = staker @ StakingError::Unauthorized,
        constraint = position.pool != Pubkey::default() @ StakingError::InvalidPool
    )]
    pub position: Account<'info, StakePosition>,
    #[account(
        mut,
        constraint = fl_dao_mint.key() == rewards_config.fl_dao_mint @ StakingError::InvalidMint
    )]
    pub fl_dao_mint: Account<'info, Mint>,
    #[account(
        mut,
        constraint = user_fl_dao_account.owner == staker.key() @ StakingError::Unauthorized,
        constraint = user_fl_dao_account.mint == rewards_config.fl_dao_mint @ StakingError::InvalidMint
    )]
    pub user_fl_dao_account: Account<'info, TokenAccount>,
    /// CHECK: Validated via seeds and constraint
    #[account(
        seeds = [b"mint_authority"],
        bump,
        constraint = mint_authority.key() == rewards_config.mint_authority @ StakingError::Unauthorized
    )]
    pub mint_authority: UncheckedAccount<'info>,
    pub staker: Signer<'info>,
    pub token_program: Program<'info, Token>,
}

pub fn exchange_points(ctx: Context<ExchangePoints>, points: u128, min_out: u64) -> Result<()> {
    // CHECKS
    let rewards_config = &mut ctx.accounts.rewards_config;
    let position = &mut ctx.accounts.position;

    require!(!rewards_config.paused, StakingError::Unauthorized);
    require!(
        position.accum_points >= points,
        StakingError::InsufficientPoints
    );

    let fldao_amount = points_to_fldao(points, rewards_config.exchange_rate)?;
    require!(fldao_amount >= min_out, StakingError::InvalidAmount);

    // EFFECTS (update state BEFORE external calls)
    position.accum_points = position
        .accum_points
        .checked_sub(points)
        .ok_or(StakingError::MathOverflow)?;

    rewards_config.global_fldao_minted = rewards_config
        .global_fldao_minted
        .checked_add(fldao_amount)
        .ok_or(StakingError::MathOverflow)?;

    // INTERACTIONS (external calls last)
    let mint_authority_bump = ctx.bumps.mint_authority;
    let mint_authority_seeds = &[b"mint_authority".as_ref(), &[mint_authority_bump]];

    token::mint_to(
        CpiContext::new_with_signer(
            ctx.accounts.token_program.to_account_info(),
            MintTo {
                mint: ctx.accounts.fl_dao_mint.to_account_info(),
                to: ctx.accounts.user_fl_dao_account.to_account_info(),
                authority: ctx.accounts.mint_authority.to_account_info(),
            },
            &[mint_authority_seeds],
        ),
        fldao_amount,
    )?;

    let clock = Clock::get()?;

    emit!(PointsExchanged {
        staker: position.staker,
        points_burned: points,
        fldao_minted: fldao_amount,
        exchange_rate: rewards_config.exchange_rate,
        timestamp: clock.unix_timestamp,
    });

    Ok(())
}

staking.rs
use crate::errors::StakingError;
use crate::events::{Staked, Unstaked};
use crate::state_accounts::{StakePool, StakePosition};
use crate::utils::update_position_points;
use anchor_lang::prelude::*;
use anchor_spl::token::{self, Token, TokenAccount, Transfer};

#[derive(Accounts)]
pub struct Stake<'info> {
    #[account(mut)]
    pub pool: Account<'info, StakePool>,
    #[account(
        mut,
        constraint = vault.key() == pool.vault @ StakingError::InvalidVault,
        constraint = vault.mint == pool.mint @ StakingError::InvalidMint
    )]
    pub vault: Account<'info, TokenAccount>,
    #[account(
        init_if_needed,
        payer = staker,
        space = StakePosition::SPACE,
        seeds = [b"position", pool.key().as_ref(), staker.key().as_ref()],
        bump
    )]
    pub position: Account<'info, StakePosition>,
    #[account(mut)]
    pub staker: Signer<'info>,
    #[account(
        mut,
        constraint = staker_token_account.owner == staker.key() @ StakingError::Unauthorized,
        constraint = staker_token_account.mint == pool.mint @ StakingError::InvalidMint
    )]
    pub staker_token_account: Account<'info, TokenAccount>,
    pub token_program: Program<'info, Token>,
    pub system_program: Program<'info, System>,
}

pub fn stake(ctx: Context<Stake>, amount: u64) -> Result<()> {
    let pool = &mut ctx.accounts.pool;
    let position = &mut ctx.accounts.position;
    let clock = Clock::get()?;

    require!(!pool.paused, StakingError::PoolPaused);
    require!(amount > 0, StakingError::AmountTooSmall);

    // Update points before changing stake amount
    update_position_points(position, pool, clock.unix_timestamp)?;

    // Initialize position if first stake
    if position.staker == Pubkey::default() {
        position.staker = ctx.accounts.staker.key();
        position.pool = pool.key();
        position.amount = 0;
        position.accum_points = 0;
        position.created_at = clock.unix_timestamp;
        position.last_update_ts = clock.unix_timestamp;
        position.bump = ctx.bumps.position;
    }

    // ADD THIS CHECK:
    let new_amount = position
        .amount
        .checked_add(amount)
        .ok_or(StakingError::MathOverflow)?;

    require!(
        new_amount <= pool.max_stake_per_user,
        StakingError::StakeLimitExceeded
    );

    // Transfer tokens to vault
    token::transfer(
        CpiContext::new(
            ctx.accounts.token_program.to_account_info(),
            Transfer {
                from: ctx.accounts.staker_token_account.to_account_info(),
                to: ctx.accounts.vault.to_account_info(),
                authority: ctx.accounts.staker.to_account_info(),
            },
        ),
        amount,
    )?;

    // Update amounts
    position.amount = new_amount; // CHANGE THIS LINE

    pool.total_staked = pool
        .total_staked
        .checked_add(amount)
        .ok_or(StakingError::MathOverflow)?;

    emit!(Staked {
        pool: pool.key(),
        staker: position.staker,
        amount,
        new_total: position.amount,
        timestamp: clock.unix_timestamp,
    });

    Ok(())
}

#[derive(Accounts)]
pub struct Unstake<'info> {
    #[account(mut)]
    pub pool: Account<'info, StakePool>,
    #[account(
        mut,
        constraint = vault.key() == pool.vault @ StakingError::InvalidVault,
        constraint = vault.mint == pool.mint @ StakingError::InvalidMint
    )]
    pub vault: Account<'info, TokenAccount>,
    #[account(
        mut,
        has_one = staker @ StakingError::Unauthorized,
        has_one = pool @ StakingError::InvalidPool
    )]
    pub position: Account<'info, StakePosition>,
    #[account(mut)]
    pub staker: Signer<'info>,
    #[account(
        mut,
        constraint = staker_token_account.owner == staker.key() @ StakingError::Unauthorized,
        constraint = staker_token_account.mint == pool.mint @ StakingError::InvalidMint
    )]
    pub staker_token_account: Account<'info, TokenAccount>,
    pub token_program: Program<'info, Token>,
}

pub fn unstake(ctx: Context<Unstake>, amount: u64) -> Result<()> {
    let pool = &mut ctx.accounts.pool;
    let position = &mut ctx.accounts.position;
    let clock = Clock::get()?;

    // NOTE: Intentionally allowing unstake even when pool is paused
    // This ensures users can always withdraw their funds
    // Only staking is blocked when paused

    require!(amount > 0, StakingError::AmountTooSmall);
    require!(position.amount >= amount, StakingError::InsufficientStaked);

    // Update points before changing stake amount
    update_position_points(position, pool, clock.unix_timestamp)?;

    // Transfer tokens back to user
    let pool_seeds = &[b"pool", pool.mint.as_ref(), &[pool.bump]];

    token::transfer(
        CpiContext::new_with_signer(
            ctx.accounts.token_program.to_account_info(),
            Transfer {
                from: ctx.accounts.vault.to_account_info(),
                to: ctx.accounts.staker_token_account.to_account_info(),
                authority: pool.to_account_info(),
            },
            &[pool_seeds],
        ),
        amount,
    )?;

    // Update amounts
    position.amount = position
        .amount
        .checked_sub(amount)
        .ok_or(StakingError::MathOverflow)?;

    pool.total_staked = pool
        .total_staked
        .checked_sub(amount)
        .ok_or(StakingError::MathOverflow)?;

    emit!(Unstaked {
        pool: pool.key(),
        staker: position.staker,
        amount,
        remaining: position.amount,
        timestamp: clock.unix_timestamp,
    });

    Ok(())
}

#[derive(Accounts)]
pub struct SyncPosition<'info> {
    #[account(mut)]
    pub pool: Account<'info, StakePool>,
    #[account(
        mut,
        has_one = staker @ StakingError::Unauthorized,
        has_one = pool @ StakingError::InvalidPool
    )]
    pub position: Account<'info, StakePosition>,
    pub staker: Signer<'info>,
}

pub fn sync_position(ctx: Context<SyncPosition>) -> Result<()> {
    let pool = &mut ctx.accounts.pool;
    let position = &mut ctx.accounts.position;
    let clock = Clock::get()?;

    let points_earned = update_position_points(position, pool, clock.unix_timestamp)?;

    if points_earned > 0 {
        emit!(crate::events::PointsAccrued {
            pool: pool.key(),
            staker: position.staker,
            delta_points: points_earned,
            total_points: position.accum_points,
            timestamp: clock.unix_timestamp,
        });
    }

    Ok(())
}

utils.rs
use anchor_lang::prelude::*;
use crate::state_accounts::StakePosition;
use crate::errors::StakingError;

#[derive(Accounts)]
pub struct GetStakedAmount<'info> {
    #[account(
        has_one = staker @ StakingError::Unauthorized
    )]
    pub position: Account<'info, StakePosition>,
    pub staker: Signer<'info>,
}

pub fn get_staked_amount(ctx: Context<GetStakedAmount>) -> Result<u64> {
    Ok(ctx.accounts.position.amount)
}

outside instruction folder
constants
use anchor_lang::prelude::*;

// Cross-program IDs
pub const GOVERNANCE_PROGRAM_ID: Pubkey = anchor_lang::pubkey!("GgkLgFNYnDsCo4w9NKZrjMnhjaJ5F3XjNTMfvGjaxgFf");
pub const STAKING_PROGRAM_ID: Pubkey = anchor_lang::pubkey!("DFv6N5EiAueb7xcntYB3ZL49dFbAmgimXsfgwobZpfv9");


errors.rs
use anchor_lang::prelude::*;

#[error_code]
pub enum StakingError {
    #[msg("Unauthorized access")]
    Unauthorized,
    #[msg("Pool is paused")]
    PoolPaused,
    #[msg("Amount too small")]
    AmountTooSmall,
    #[msg("Insufficient staked amount")]
    InsufficientStaked,
    #[msg("Math overflow")]
    MathOverflow,
    #[msg("Invalid exchange rate")]
    InvalidExchangeRate,
    #[msg("Insufficient points")]
    InsufficientPoints,
    #[msg("Invalid pool")]
    InvalidPool,
    #[msg("Position not found")]
    PositionNotFound,
    #[msg("Invalid amount")]
    InvalidAmount,
    #[msg("Invalid mint")]
    InvalidMint,
    #[msg("Invalid vault")]
    InvalidVault,
    #[msg("Stake limit exceeded")]
    StakeLimitExceeded,
}

//events
use anchor_lang::prelude::*;

#[event]
pub struct RewardsConfigInitialized {
    pub admin: Pubkey,
    pub fl_dao_mint: Pubkey,
    pub exchange_rate: u64,
    pub timestamp: i64,
}

#[event]
pub struct PoolInitialized {
    pub pool: Pubkey,
    pub mint: Pubkey,
    pub is_lp: bool,
    pub points_per_token_per_second: u64,
    pub timestamp: i64,
}

#[event]
pub struct Staked {
    pub pool: Pubkey,
    pub staker: Pubkey,
    pub amount: u64,
    pub new_total: u64,
    pub timestamp: i64,
}

#[event]
pub struct Unstaked {
    pub pool: Pubkey,
    pub staker: Pubkey,
    pub amount: u64,
    pub remaining: u64,
    pub timestamp: i64,
}

#[event]
pub struct PointsAccrued {
    pub pool: Pubkey,
    pub staker: Pubkey,
    pub delta_points: u128,
    pub total_points: u128,
    pub timestamp: i64,
}

#[event]
pub struct PointsExchanged {
    pub staker: Pubkey,
    pub points_burned: u128,
    pub fldao_minted: u64,
    pub exchange_rate: u64,
    pub timestamp: i64,
}

#[event]
pub struct PoolParamsUpdated {
    pub pool: Pubkey,
    pub new_rate: Option<u64>,
    pub paused: Option<bool>,
    pub timestamp: i64,
}

#[event]
pub struct RewardsParamsUpdated {
    pub new_exchange_rate: Option<u64>,
    pub paused: Option<bool>,
    pub timestamp: i64,
}


lib.rs
use anchor_lang::prelude::*;

pub mod constants;
pub mod errors;
pub mod events;
pub mod instructions;
pub mod math;
pub mod state_accounts;
pub mod utils;

use instructions::*;

declare_id!("DFv6N5EiAueb7xcntYB3ZL49dFbAmgimXsfgwobZpfv9");

#[program]
pub mod staking {
    use super::*;

    // Initialization functions
    pub fn init_rewards_config(
        ctx: Context<InitRewardsConfig>,
        fl_dao_mint: Pubkey,
        exchange_rate: u64,
        admin: Pubkey,
    ) -> Result<()> {
        instructions::init::init_rewards_config(ctx, fl_dao_mint, exchange_rate, admin)
    }

    pub fn init_pool(
        ctx: Context<InitPool>,
        mint: Pubkey,
        is_lp: bool,
        points_per_token_per_second: u64,
        max_stake_per_user: u64, // ADD THIS
    ) -> Result<()> {
        instructions::init::init_pool(
            ctx,
            mint,
            is_lp,
            points_per_token_per_second,
            max_stake_per_user,
        )
    }

    // Staking functions
    pub fn stake(ctx: Context<Stake>, amount: u64) -> Result<()> {
        instructions::staking::stake(ctx, amount)
    }

    pub fn unstake(ctx: Context<Unstake>, amount: u64) -> Result<()> {
        instructions::staking::unstake(ctx, amount)
    }

    pub fn sync_position(ctx: Context<SyncPosition>) -> Result<()> {
        instructions::staking::sync_position(ctx)
    }

    // Rewards functions
    pub fn exchange_points(ctx: Context<ExchangePoints>, points: u128, min_out: u64) -> Result<()> {
        instructions::rewards::exchange_points(ctx, points, min_out)
    }

    // Admin functions
    pub fn set_pool_params(
        ctx: Context<SetPoolParams>,
        rate: Option<u64>,
        paused: Option<bool>,
    ) -> Result<()> {
        instructions::admin::set_pool_params(ctx, rate, paused)
    }

    pub fn set_rewards_params(
        ctx: Context<SetRewardsParams>,
        rate: Option<u64>,
        paused: Option<bool>,
    ) -> Result<()> {
        instructions::admin::set_rewards_params(ctx, rate, paused)
    }

    // Utility functions
    pub fn get_staked_amount(ctx: Context<GetStakedAmount>) -> Result<u64> {
        instructions::utils::get_staked_amount(ctx)
    }

    pub fn get_position(ctx: Context<GetPosition>) -> Result<(u64, u128)> {
        instructions::query::get_position(ctx)
    }

    pub fn view_position(ctx: Context<ViewPosition>) -> Result<u64> {
        instructions::query::view_position(ctx)
    }
}

math.rs
// programs/staking/src/math.rs
use crate::errors::StakingError;
use anchor_lang::prelude::*;

// Q32.32 fixed point for precise points calculation
pub const Q32: u64 = 1u64 << 32;

// Maximum duration to prevent overflow (10 years in seconds)
// This protects against: u64::MAX seconds (~584 billion years) causing overflow
pub const MAX_DURATION_SECONDS: i64 = 10 * 365 * 86400; // 315,360,000 seconds

// Maximum rate to prevent overflow in calculations
// With Q32 format: (2^32 = 4,294,967,296)
// This allows rates up to ~1000 tokens per token per second when properly scaled
pub const MAX_RATE_PER_SECOND: u64 = u64::MAX / 1000;

pub fn calculate_points_accrued(
    amount: u64,
    rate_per_second: u64, // Q32.32 format
    duration_seconds: i64,
) -> Result<u128> {
    // Handle negative or zero duration
    if duration_seconds <= 0 {
        return Ok(0);
    }

    // Cap duration to prevent overflow attacks
    // If someone stakes for 10+ years, they'll need to sync periodically
    let capped_duration = if duration_seconds > MAX_DURATION_SECONDS {
        MAX_DURATION_SECONDS
    } else {
        duration_seconds
    };

    let duration = capped_duration as u128;
    let amount_expanded = amount as u128;
    let rate_expanded = rate_per_second as u128;

    // Validate inputs before calculation
    require!(
        rate_per_second <= MAX_RATE_PER_SECOND,
        StakingError::InvalidAmount
    );

    // Calculate: points = (amount * rate * duration) / Q32
    // Break into steps to detect overflow early

    // Step 1: amount * rate
    let amount_times_rate = amount_expanded
        .checked_mul(rate_expanded)
        .ok_or(StakingError::MathOverflow)?;

    // Step 2: (amount * rate) * duration
    let numerator = amount_times_rate
        .checked_mul(duration)
        .ok_or(StakingError::MathOverflow)?;

    // Step 3: divide by Q32 to get final points
    let points = numerator
        .checked_div(Q32 as u128)
        .ok_or(StakingError::MathOverflow)?;

    Ok(points)
}

pub fn points_to_fldao(points: u128, exchange_rate: u64) -> Result<u64> {
    // Validate exchange rate
    require!(exchange_rate > 0, StakingError::InvalidExchangeRate);

    // Calculate FLDAO tokens: fldao = points / exchange_rate
    let fldao_amount = points
        .checked_div(exchange_rate as u128)
        .ok_or(StakingError::MathOverflow)?;

    // Ensure result fits in u64
    require!(fldao_amount <= u64::MAX as u128, StakingError::MathOverflow);

    Ok(fldao_amount as u64)
}

// Convert daily rate to per-second Q32.32 format
// daily_rate: tokens earned per token per day
// Returns: Q32.32 formatted rate per second
pub fn daily_rate_to_per_second(daily_rate: u64) -> Result<u64> {
    require!(daily_rate > 0, StakingError::InvalidAmount);

    // rate_per_second = (daily_rate * Q32) / 86400
    // Break into steps for safety
    let daily_rate_expanded = daily_rate as u128;
    let q32_expanded = Q32 as u128;

    let numerator = daily_rate_expanded
        .checked_mul(q32_expanded)
        .ok_or(StakingError::MathOverflow)?;

    let rate_per_second = numerator
        .checked_div(86400u128)
        .ok_or(StakingError::MathOverflow)?;

    // Ensure result fits in u64
    require!(
        rate_per_second <= u64::MAX as u128,
        StakingError::MathOverflow
    );

    Ok(rate_per_second as u64)
}

state_accounts.rs
use anchor_lang::prelude::*;

#[account]
#[derive(Default)]
pub struct RewardsConfig {
    pub admin: Pubkey,              // 32
    pub fl_dao_mint: Pubkey,        // 32
    pub exchange_rate: u64,         // 8   (points per $FLDAO)
    pub treasury: Pubkey,           // 32  (treasury PDA)
    pub mint_authority: Pubkey,     // 32  (PDA for minting)
    pub global_points_issued: u128, // 16  (tracking)
    pub global_fldao_minted: u64,   // 8   (tracking)
    pub paused: bool,               // 1
    pub bump: u8,                   // 1
}

impl RewardsConfig {
    pub const SPACE: usize = 8 + 32 * 4 + 8 + 16 + 8 + 1 + 1; // 170 bytes
}

#[account]
#[derive(Default)]
pub struct StakePool {
    pub mint: Pubkey,                     // 32
    pub vault: Pubkey,                    // 32
    pub is_lp: bool,                      // 1
    pub points_per_token_per_second: u64, // 8
    pub total_staked: u64,                // 8
    pub total_points_issued: u128,        // 16
    pub created_at: i64,                  // 8
    pub paused: bool,                     // 1
    pub bump: u8,                         // 1
    pub max_stake_per_user: u64,          // 8  <- ADD THIS
}

impl StakePool {
    pub const SPACE: usize = 8 + 32 * 2 + 1 + 8 * 4 + 16 + 1 + 1; // 123 bytes (was 115)
}

#[account]
#[derive(Default)]
pub struct StakePosition {
    pub staker: Pubkey,      // 32
    pub pool: Pubkey,        // 32  (StakePool PDA)
    pub amount: u64,         // 8   (tokens staked)
    pub accum_points: u128,  // 16  (accrued staking points)
    pub last_update_ts: i64, // 8   (for point calculation)
    pub created_at: i64,     // 8
    pub bump: u8,            // 1
}

impl StakePosition {
    pub const SPACE: usize = 8 + 32 * 2 + 8 + 16 + 8 + 8 + 1; // 113 bytes
}

utils.rs
// FIXED utils.rs - Add missing import
use crate::{
    errors::StakingError,
    math::calculate_points_accrued,
    state_accounts::{StakePool, StakePosition},
};
use anchor_lang::prelude::*;

pub fn update_position_points(
    position: &mut StakePosition,
    pool: &mut StakePool,
    current_timestamp: i64,
) -> Result<u128> {
    if position.amount == 0 {
        position.last_update_ts = current_timestamp;
        return Ok(0);
    }

    let duration = current_timestamp - position.last_update_ts;
    if duration <= 0 {
        return Ok(0);
    }

    let points_earned =
        calculate_points_accrued(position.amount, pool.points_per_token_per_second, duration)?;

    position.accum_points = position
        .accum_points
        .checked_add(points_earned)
        .ok_or(StakingError::MathOverflow)?;

    pool.total_points_issued = pool
        .total_points_issued
        .checked_add(points_earned)
        .ok_or(StakingError::MathOverflow)?;

    position.last_update_ts = current_timestamp;

    Ok(points_earned)
}

cargo
[package]
name = "staking"
version = "0.1.0"
description = "Staking smart contract for FreelanceDao"
edition = "2021"

[lib]
crate-type = ["cdylib", "lib"]
name = "staking"

[features]
default = []
cpi = ["no-entrypoint"]
no-entrypoint = []
no-idl = []
no-log-ix-name = []
idl-build = [
    "anchor-lang/idl-build",
    "anchor-spl/idl-build",
]
custom-heap = []
custom-panic = []
anchor-debug = []

[dependencies]
anchor-lang = { version = "0.31.1", features = ["init-if-needed"] }
anchor-spl = "0.31.1"
shared = { path = "../shared" }