//disputes smart contract
//instructions folder
//execute_judgment.rs
use crate::error::DisputeError;
use crate::events::DisputeExecuted;
use crate::state::{AdminConfig, Dispute, DisputeState};
use anchor_lang::prelude::*;

// ADD THESE IMPORTS
use anchor_lang::solana_program::program::invoke_signed;

#[derive(Accounts)]
pub struct ExecuteJudgment<'info> {
    #[account(mut)]
    pub executor: Signer<'info>,

    #[account(
        seeds = [b"admin_config"],
        bump = admin_config.bump,
        constraint = admin_config.authority == executor.key() @ DisputeError::Unauthorized
    )]
    pub admin_config: Account<'info, AdminConfig>,

    #[account(
        mut,
        constraint = dispute.state == DisputeState::Judged @ DisputeError::InvalidDisputeState,
        constraint = dispute.judgment.is_some() @ DisputeError::InvalidDisputeState
    )]
    pub dispute: Account<'info, Dispute>,

    // CHANGE FROM Option TO REQUIRED WHEN ESCROW EXISTS
    /// CHECK: The escrow program - validated by the dispute's linked_escrow field
    #[account(
        constraint = escrow_program.key() == crate::ESCROW_PROGRAM_ID @ DisputeError::InvalidEscrowAccount
    )]
    pub escrow_program: UncheckedAccount<'info>,

    /// CHECK: The escrow account - validated by CPI call
    #[account(
        mut,
        constraint = escrow_account.owner == &escrow_program.key() @ DisputeError::InvalidEscrowAccount,
    )]
    pub escrow_account: UncheckedAccount<'info>,

    // ADD THESE ACCOUNTS FOR ESCROW CPI
    /// CHECK: Client account to receive funds
    #[account(mut)]
    pub client: UncheckedAccount<'info>,

    /// CHECK: Freelancer account to receive funds
    #[account(mut)]
    pub freelancer: UncheckedAccount<'info>,

    /// CHECK: Vault holding the escrowed funds
    #[account(mut)]
    pub vault: UncheckedAccount<'info>,

    pub system_program: Program<'info, System>,
    // ADD IF YOUR ESCROW USES SPL TOKENS
    // pub token_program: Program<'info, Token>,
}

pub fn handler(ctx: Context<ExecuteJudgment>) -> Result<()> {
    let dispute = &mut ctx.accounts.dispute;
    let clock = Clock::get()?;

    // REENTRANCY GUARD: Change state BEFORE any CPI calls
    let judgment_choice = dispute.judgment.as_ref().unwrap().choice.clone();
    let linked_escrow = dispute.linked_escrow;

    dispute.state = DisputeState::Executed;

    // REPLACE THE TODO WITH ACTUAL CPI
    if let Some(escrow_key) = linked_escrow {
        // Validate the escrow account matches
        require!(
            ctx.accounts.escrow_account.key() == escrow_key,
            DisputeError::InvalidEscrowAccount
        );

        msg!("Executing judgment for escrow: {}", escrow_key);

        // Create the dispute PDA seeds for signing
        let dispute_seeds = &[b"dispute", &dispute.id.to_le_bytes()[..], &[dispute.bump]];
        let signer_seeds = &[&dispute_seeds[..]];

        // Build the CPI instruction based on your escrow program's interface
        // ADJUST THIS BASED ON YOUR ACTUAL ESCROW PROGRAM INSTRUCTIONS
        match judgment_choice {
            crate::state::JudgmentChoice::Client => {
                // Release 100% to client
                let ix = anchor_lang::solana_program::instruction::Instruction {
                    program_id: ctx.accounts.escrow_program.key(),
                    accounts: vec![
                        AccountMeta::new(ctx.accounts.escrow_account.key(), false),
                        AccountMeta::new(ctx.accounts.client.key(), false),
                        AccountMeta::new(ctx.accounts.vault.key(), false),
                        AccountMeta::new_readonly(dispute.key(), true), // Dispute as authority
                        AccountMeta::new_readonly(ctx.accounts.system_program.key(), false),
                    ],
                    data: vec![0], // Your escrow instruction discriminator for "release_to_client"
                };

                invoke_signed(
                    &ix,
                    &[
                        ctx.accounts.escrow_account.to_account_info(),
                        ctx.accounts.client.to_account_info(),
                        ctx.accounts.vault.to_account_info(),
                        dispute.to_account_info(),
                        ctx.accounts.system_program.to_account_info(),
                    ],
                    signer_seeds,
                )?;
            }
            crate::state::JudgmentChoice::Freelancer => {
                // Release 100% to freelancer
                let ix = anchor_lang::solana_program::instruction::Instruction {
                    program_id: ctx.accounts.escrow_program.key(),
                    accounts: vec![
                        AccountMeta::new(ctx.accounts.escrow_account.key(), false),
                        AccountMeta::new(ctx.accounts.freelancer.key(), false),
                        AccountMeta::new(ctx.accounts.vault.key(), false),
                        AccountMeta::new_readonly(dispute.key(), true),
                        AccountMeta::new_readonly(ctx.accounts.system_program.key(), false),
                    ],
                    data: vec![1], // Your escrow instruction discriminator for "release_to_freelancer"
                };

                invoke_signed(
                    &ix,
                    &[
                        ctx.accounts.escrow_account.to_account_info(),
                        ctx.accounts.freelancer.to_account_info(),
                        ctx.accounts.vault.to_account_info(),
                        dispute.to_account_info(),
                        ctx.accounts.system_program.to_account_info(),
                    ],
                    signer_seeds,
                )?;
            }
            crate::state::JudgmentChoice::Split(percentage) => {
                // Split based on percentage
                require!(percentage <= 100, DisputeError::InvalidJudgmentChoice);

                // Encode percentage as instruction data
                let mut data = vec![2]; // Discriminator for "split_release"
                data.extend_from_slice(&percentage.to_le_bytes());

                let ix = anchor_lang::solana_program::instruction::Instruction {
                    program_id: ctx.accounts.escrow_program.key(),
                    accounts: vec![
                        AccountMeta::new(ctx.accounts.escrow_account.key(), false),
                        AccountMeta::new(ctx.accounts.client.key(), false),
                        AccountMeta::new(ctx.accounts.freelancer.key(), false),
                        AccountMeta::new(ctx.accounts.vault.key(), false),
                        AccountMeta::new_readonly(dispute.key(), true),
                        AccountMeta::new_readonly(ctx.accounts.system_program.key(), false),
                    ],
                    data,
                };

                invoke_signed(
                    &ix,
                    &[
                        ctx.accounts.escrow_account.to_account_info(),
                        ctx.accounts.client.to_account_info(),
                        ctx.accounts.freelancer.to_account_info(),
                        ctx.accounts.vault.to_account_info(),
                        dispute.to_account_info(),
                        ctx.accounts.system_program.to_account_info(),
                    ],
                    signer_seeds,
                )?;
            }
        }
    }

    emit!(DisputeExecuted {
        dispute_id: dispute.id,
        judgment: judgment_choice,
        linked_escrow,
        timestamp: clock.unix_timestamp,
    });

    Ok(())
}

//finalize_judgment.rs
use crate::error::DisputeError;
use crate::events::DisputeJudged;
use crate::state::{
    AdminConfig, Dispute, DisputePanel, DisputeState, Judgment, JudgmentChoice, PanelVoteRecord,
};
use anchor_lang::prelude::*;

#[derive(Accounts)]
pub struct FinalizeJudgment<'info> {
    #[account(mut)]
    pub finalizer: Signer<'info>,

    #[account(
        seeds = [b"admin_config"],
        bump = admin_config.bump,
        constraint = admin_config.authority == finalizer.key() @ DisputeError::Unauthorized
    )]
    pub admin_config: Account<'info, AdminConfig>,

    #[account(
        mut,
        constraint = dispute.state == DisputeState::PanelFormed || dispute.state == DisputeState::Deliberating @ DisputeError::InvalidDisputeState,
        constraint = dispute.judgment.is_none() @ DisputeError::JudgmentAlreadyFinalized
    )]
    pub dispute: Account<'info, Dispute>,

    #[account(
        seeds = [b"panel", &dispute.id.to_le_bytes()[..]],
        bump = panel.bump
    )]
    pub panel: Account<'info, DisputePanel>,
}

pub fn handler<'info>(ctx: Context<'_, '_, 'info, 'info, FinalizeJudgment<'info>>) -> Result<()> {
    let dispute = &mut ctx.accounts.dispute;
    let panel = &ctx.accounts.panel;
    let clock = Clock::get()?;

    // Check panel hasn't expired
    require!(
        clock.unix_timestamp < panel.expires_at,
        DisputeError::DisputeExpired
    );

    // Check quorum reached
    require!(
        panel.total_votes_cast >= dispute.required_quorum,
        DisputeError::QuorumNotReached
    );

    // Tally votes from remaining accounts
    let mut client_votes: u32 = 0;
    let mut freelancer_votes: u32 = 0;
    let mut split_votes: u32 = 0;
    let mut total_weighted: u32 = 0;

    // Iterate through remaining accounts (vote records)
    for account_info in ctx.remaining_accounts.iter() {
        // Deserialize vote record
        let vote_record: Account<PanelVoteRecord> = Account::try_from(account_info)?;

        // Validate this vote belongs to this dispute
        require!(
            vote_record.dispute_id == dispute.id,
            DisputeError::InvalidVoteRecord
        );

        // Validate voter is panel member
        require!(
            panel.is_member(&vote_record.voter),
            DisputeError::NotPanelMember
        );

        // UPDATED SECTION: Enhanced overflow protection
        let weight = vote_record.weight as u32;

        // Add overflow check before adding
        let new_total = total_weighted
            .checked_add(weight)
            .ok_or(DisputeError::ArithmeticOverflow)?;

        // Also check against expected maximum to prevent vote stuffing
        require!(
            new_total <= panel.weighted_votes_cast,
            DisputeError::VoteMismatch
        );

        total_weighted = new_total;

        match vote_record.choice {
            JudgmentChoice::Client => {
                client_votes = client_votes
                    .checked_add(weight)
                    .ok_or(DisputeError::ArithmeticOverflow)?;
            }
            JudgmentChoice::Freelancer => {
                freelancer_votes = freelancer_votes
                    .checked_add(weight)
                    .ok_or(DisputeError::ArithmeticOverflow)?;
            }
            JudgmentChoice::Split(_) => {
                split_votes = split_votes
                    .checked_add(weight)
                    .ok_or(DisputeError::ArithmeticOverflow)?;
            }
        }
    }

    // Verify vote count matches panel records exactly
    require!(
        total_weighted == panel.weighted_votes_cast,
        DisputeError::VoteMismatch
    );

    // Determine winner (simple majority)
    let winning_choice = if client_votes > freelancer_votes && client_votes > split_votes {
        JudgmentChoice::Client
    } else if freelancer_votes > client_votes && freelancer_votes > split_votes {
        JudgmentChoice::Freelancer
    } else if split_votes > client_votes && split_votes > freelancer_votes {
        JudgmentChoice::Split(50) // Default 50-50 split
    } else {
        // Tie-breaker: favor split
        JudgmentChoice::Split(50)
    };

    dispute.judgment = Some(Judgment {
        choice: winning_choice.clone(),
        finalized_at: clock.unix_timestamp,
    });
    dispute.state = DisputeState::Judged;

    emit!(DisputeJudged {
        dispute_id: dispute.id,
        judgment: winning_choice,
        total_votes: panel.total_votes_cast,
        weighted_votes: panel.weighted_votes_cast,
        timestamp: clock.unix_timestamp,
    });

    Ok(())
}

//cancel_dispute.rs
use anchor_lang::prelude::*;
use crate::error::DisputeError;
use crate::events::DisputeCanceled;
use crate::state::{AdminConfig, Dispute, DisputeState};

#[derive(Accounts)]
pub struct CancelDispute<'info> {
    #[account(mut)]
    pub canceler: Signer<'info>,

    #[account(
        seeds = [b"admin_config"],
        bump = admin_config.bump
    )]
    pub admin_config: Account<'info, AdminConfig>,

    #[account(
        mut,
        constraint = dispute.state == DisputeState::Pending 
            || dispute.state == DisputeState::PanelFormed 
            || dispute.state == DisputeState::Deliberating 
            @ DisputeError::CannotCancel
    )]
    pub dispute: Account<'info, Dispute>,
}

pub fn handler(ctx: Context<CancelDispute>) -> Result<()> {
    let dispute = &mut ctx.accounts.dispute;
    let canceler = ctx.accounts.canceler.key();
    let clock = Clock::get()?;

    // Authorization: Either dispute opener or admin can cancel
    let is_opener = dispute.opened_by == canceler;
    let is_admin = ctx.accounts.admin_config.authority == canceler;
    
    require!(
        is_opener || is_admin,
        DisputeError::UnauthorizedCancel
    );

    // Additional restriction: opener can only cancel before judgment
    if is_opener && !is_admin {
        require!(
            dispute.state != DisputeState::Judged && dispute.state != DisputeState::Executed,
            DisputeError::CannotCancel
        );
    }

    let previous_state = dispute.state.clone();
    dispute.state = DisputeState::Canceled;

    emit!(DisputeCanceled {
        dispute_id: dispute.id,
        canceled_by: canceler,
        previous_state,
        timestamp: clock.unix_timestamp,
    });

    Ok(())
}

//form_panel.rs
use crate::error::DisputeError;
use crate::events::PanelFormed;
use crate::state::{AdminConfig, Dispute, DisputePanel, DisputeState};
use anchor_lang::prelude::*;

#[derive(Accounts)]
pub struct FormPanel<'info> {
    #[account(mut)]
    pub admin: Signer<'info>,

    #[account(
        seeds = [b"admin_config"],
        bump = admin_config.bump,
        constraint = admin_config.authority == admin.key() @ DisputeError::Unauthorized
    )]
    pub admin_config: Account<'info, AdminConfig>,

    #[account(
        mut,
        constraint = dispute.state == DisputeState::Pending @ DisputeError::InvalidDisputeState,
        constraint = dispute.panel_size == 0 @ DisputeError::PanelAlreadyFormed
    )]
    pub dispute: Account<'info, Dispute>,

    #[account(
        init,
        payer = admin,
        space = DisputePanel::space(),
        seeds = [b"panel", &dispute.id.to_le_bytes()[..]],
        bump
    )]
    pub panel: Account<'info, DisputePanel>,

    pub system_program: Program<'info, System>,
}

pub fn handler(
    ctx: Context<FormPanel>,
    members: Vec<Pubkey>,
    selection_seed: u64,
    required_quorum: u16,
) -> Result<()> {
    require!(!members.is_empty(), DisputeError::InvalidPanelSize);
    require!(
        members.len() <= DisputePanel::MAX_PANEL_SIZE,
        DisputeError::InvalidPanelSize
    );
    require!(required_quorum > 0, DisputeError::InvalidPanelSize);
    require!(
        required_quorum <= members.len() as u16,
        DisputeError::InvalidPanelSize
    );

    // Validate no duplicate members
    let mut unique_members = members.clone();
    unique_members.sort();
    unique_members.dedup();
    require!(
        unique_members.len() == members.len(),
        DisputeError::DuplicatePanelMembers
    );

    let dispute = &mut ctx.accounts.dispute;
    let panel = &mut ctx.accounts.panel;
    let clock = Clock::get()?;

    let expires_at = clock
        .unix_timestamp
        .checked_add(14 * 24 * 60 * 60)
        .ok_or(DisputeError::ArithmeticOverflow)?;

    let weights = vec![1u16; members.len()];

    let total_weight: u32 = weights.iter().map(|&w| w as u32).sum();
    require!(
        total_weight > 0 && total_weight <= u32::MAX,
        DisputeError::InvalidPanelWeights
    );

    panel.dispute_id = dispute.id;
    panel.members = members.clone();
    panel.weights = weights;
    panel.selection_seed = selection_seed;
    panel.expires_at = expires_at;
    panel.total_votes_cast = 0;
    panel.weighted_votes_cast = 0;
    panel.bump = ctx.bumps.panel;

    dispute.state = DisputeState::PanelFormed;
    dispute.panel_size = members.len() as u16;
    dispute.required_quorum = required_quorum;

    emit!(PanelFormed {
        dispute_id: dispute.id,
        members,
        panel_size: dispute.panel_size,
        required_quorum,
        expires_at,
    });

    Ok(())
}


//init_counter.rs
use crate::state::{AdminConfig, DisputeCounter};
use anchor_lang::prelude::*;

#[derive(Accounts)]
pub struct InitCounter<'info> {
    #[account(mut)]
    pub admin: Signer<'info>,

    #[account(
        init,
        payer = admin,
        space = AdminConfig::SPACE,
        seeds = [b"admin_config"],
        bump
    )]
    pub admin_config: Account<'info, AdminConfig>,

    #[account(
        init,
        payer = admin,
        space = DisputeCounter::SPACE,
        seeds = [b"dispute_counter"],
        bump
    )]
    pub counter: Account<'info, DisputeCounter>,

    pub system_program: Program<'info, System>,
}

pub fn handler(ctx: Context<InitCounter>) -> Result<()> {
    let counter = &mut ctx.accounts.counter;
    counter.count = 0;
    counter.bump = ctx.bumps.counter;

    let admin_config = &mut ctx.accounts.admin_config;
    admin_config.authority = ctx.accounts.admin.key();
    admin_config.bump = ctx.bumps.admin_config;

    Ok(())
}

//mod.rs
pub mod cancel_dispute;
pub mod execute_judgment;
pub mod finalize_judgment;
pub mod form_panel;
pub mod init_counter;
pub mod open_dispute;
pub mod panel_vote; // ADD THIS

pub use cancel_dispute::*;
pub use execute_judgment::*;
pub use finalize_judgment::*;
pub use form_panel::*;
pub use init_counter::*;
pub use open_dispute::*;
pub use panel_vote::*; // ADD THIS

//open_dispute.rs
use anchor_lang::prelude::*;
use crate::error::DisputeError;
use crate::events::DisputeOpened;
use crate::state::{Dispute, DisputeState, DisputeCounter};

#[derive(Accounts)]
#[instruction(parties: Vec<Pubkey>, uri: String)]
pub struct OpenDispute<'info> {
    #[account(mut)]
    pub opener: Signer<'info>,
    
    #[account(
        mut,
        seeds = [b"dispute_counter"],
        bump = counter.bump
    )]
    pub counter: Account<'info, DisputeCounter>,
    
    #[account(
        init,
        payer = opener,
        space = Dispute::space(),
        seeds = [b"dispute", &(counter.count + 1).to_le_bytes()[..]],
        bump
    )]
    pub dispute: Account<'info, Dispute>,
    
    pub system_program: Program<'info, System>,
}

pub fn handler(
    ctx: Context<OpenDispute>,
    parties: Vec<Pubkey>,
    uri: String,
    linked_escrow: Option<Pubkey>,
) -> Result<()> {
    require!(parties.len() >= 2, DisputeError::InvalidParties);
    require!(parties.len() <= Dispute::MAX_PARTIES, DisputeError::InvalidParties);
    require!(uri.len() <= Dispute::MAX_URI_LENGTH, DisputeError::UriTooLong);
    
    let counter = &mut ctx.accounts.counter;
    let dispute = &mut ctx.accounts.dispute;
    let clock = Clock::get()?;
    
    // Increment counter
    counter.count += 1;
    let dispute_id = counter.count;
    
    dispute.id = dispute_id;
    dispute.opened_by = ctx.accounts.opener.key();
    dispute.parties = parties.clone();
    dispute.uri = uri.clone();
    dispute.state = DisputeState::Pending;
    dispute.created_at = clock.unix_timestamp;
    dispute.panel_size = 0;
    dispute.required_quorum = 0;
    dispute.judgment = None;
    dispute.linked_escrow = linked_escrow;
    dispute.bump = ctx.bumps.dispute;
    
    emit!(DisputeOpened {
        id: dispute_id,
        opened_by: ctx.accounts.opener.key(),
        parties,
        uri,
        timestamp: clock.unix_timestamp,
    });
    
    Ok(())
}


//panel_vote.rs
use crate::error::DisputeError;
use crate::events::PanelVoteCast;
use crate::state::{Dispute, DisputePanel, DisputeState, JudgmentChoice, PanelVoteRecord};
use anchor_lang::prelude::*;

#[derive(Accounts)]
pub struct PanelVote<'info> {
    #[account(mut)]
    pub voter: Signer<'info>,

    // ADD mut TO DISPUTE SO WE CAN UPDATE STATE
    #[account(
        mut,  // <-- ADD THIS
        constraint = dispute.state == DisputeState::PanelFormed || dispute.state == DisputeState::Deliberating @ DisputeError::InvalidDisputeState
    )]
    pub dispute: Account<'info, Dispute>,

    #[account(
        mut,
        seeds = [b"panel", &dispute.id.to_le_bytes()[..]],
        bump = panel.bump,
        constraint = panel.is_member(&voter.key()) @ DisputeError::NotPanelMember
    )]
    pub panel: Account<'info, DisputePanel>,

    #[account(
        init,
        payer = voter,
        space = PanelVoteRecord::space(),
        seeds = [b"panel_vote", &dispute.id.to_le_bytes()[..], voter.key().as_ref()],
        bump
    )]
    pub vote_record: Account<'info, PanelVoteRecord>,

    pub system_program: Program<'info, System>,
}

pub fn handler(ctx: Context<PanelVote>, choice: JudgmentChoice) -> Result<()> {
    let dispute = &mut ctx.accounts.dispute; // Now mutable
    let panel = &mut ctx.accounts.panel;
    let vote_record = &mut ctx.accounts.vote_record;
    let clock = Clock::get()?;

    // Check if panel has expired
    require!(
        clock.unix_timestamp < panel.expires_at,
        DisputeError::DisputeExpired
    );

    // ADD THIS: Transition to Deliberating on first vote
    if dispute.state == DisputeState::PanelFormed {
        dispute.state = DisputeState::Deliberating;
        msg!("Dispute {} entered deliberation phase", dispute.id);
    }

    // Get voter's weight
    let voter_weight = panel
        .get_member_weight(&ctx.accounts.voter.key())
        .ok_or(DisputeError::NotPanelMember)?;

    // Initialize vote record
    vote_record.dispute_id = dispute.id;
    vote_record.voter = ctx.accounts.voter.key();
    vote_record.choice = choice.clone();
    vote_record.weight = voter_weight;
    vote_record.voted_at = clock.unix_timestamp;
    vote_record.bump = ctx.bumps.vote_record;

    // Update panel vote counts
    panel.total_votes_cast += 1;
    panel.weighted_votes_cast += voter_weight as u32;

    emit!(PanelVoteCast {
        dispute_id: dispute.id,
        voter: ctx.accounts.voter.key(),
        choice,
        weight: voter_weight,
        timestamp: clock.unix_timestamp,
    });

    Ok(())
}

//in state folder 
//admin_config.rs 
use anchor_lang::prelude::*;

#[account]
pub struct AdminConfig {
    pub authority: Pubkey,
    pub bump: u8,
}

impl AdminConfig {
    pub const SPACE: usize = 8 + 32 + 1 + 8; // discriminator + authority + bump + padding
}

//counter.rs
use anchor_lang::prelude::*;

#[account]
pub struct DisputeCounter {
    pub count: u64,
    pub bump: u8,
}

impl DisputeCounter {
    pub const SPACE: usize = 8 + 8 + 1 + 16; // discriminator + count + bump + padding
    
    pub fn seeds() -> &'static [&'static [u8]] {
        &[b"dispute_counter"]
    }
}

//dispute.rs
use anchor_lang::prelude::*;

#[derive(AnchorSerialize, AnchorDeserialize, Clone, PartialEq, Eq, Debug)]
pub enum DisputeState {
    Pending,
    PanelFormed,
    Deliberating,
    Judged,
    Executed,
    Canceled,
}

#[derive(AnchorSerialize, AnchorDeserialize, Clone, PartialEq, Eq, Debug)]
pub enum JudgmentChoice {
    Client,
    Freelancer,
    Split(u16), // Percentage (0-100) for client
}

#[derive(AnchorSerialize, AnchorDeserialize, Clone, Debug)]
pub struct Judgment {
    pub choice: JudgmentChoice,
    pub finalized_at: i64,
}

#[account]
pub struct Dispute {
    pub id: u64,
    pub opened_by: Pubkey,
    pub parties: Vec<Pubkey>, // client, freelancer, optional agent
    pub uri: String,          // IPFS/Arweave link to evidence
    pub state: DisputeState,
    pub created_at: i64,
    pub panel_size: u16,
    pub required_quorum: u16,
    pub judgment: Option<Judgment>,
    pub linked_escrow: Option<Pubkey>,
    pub bump: u8,
}

impl Dispute {
    pub const MAX_URI_LENGTH: usize = 200;
    pub const MAX_PARTIES: usize = 3;
    
    pub fn space() -> usize {
        8 +  // discriminator
        8 +  // id
        32 + // opened_by
        4 + (32 * Self::MAX_PARTIES) + // parties (vec + items)
        4 + Self::MAX_URI_LENGTH + // uri (string length + content)
        1 + 7 + // state (enum + padding to 8 bytes)
        8 +  // created_at
        2 +  // panel_size
        2 +  // required_quorum
        1 + (1 + 2 + 8) + // judgment (option + enum discriminant + u16 + timestamp)
        1 + 32 + // linked_escrow (option + pubkey)
        1 +  // bump
        64   // extra padding for safety
    }
}


//mod.rs
// state/mod.rs - Add this to exports
pub mod admin_config;
pub mod counter;
pub mod dispute;
pub mod panel;
pub mod panel_vote; // ← NEW

pub use admin_config::*;
pub use counter::*;
pub use dispute::*;
pub use panel::*;
pub use panel_vote::*; // ← NEW


//panel_vote.rs
use anchor_lang::prelude::*;
use super::JudgmentChoice;

#[account]
pub struct PanelVoteRecord {
    pub dispute_id: u64,
    pub voter: Pubkey,
    pub choice: JudgmentChoice,
    pub weight: u16,
    pub voted_at: i64,
    pub bump: u8,
}

impl PanelVoteRecord {
    pub fn space() -> usize {
        8 + // discriminator
        8 + // dispute_id
        32 + // voter
        1 + 2 + // choice (enum discriminant + max u16)
        2 + // weight
        8 + // voted_at
        1 + // bump
        16  // padding
    }
}

//panel.rs
use anchor_lang::prelude::*;

#[account]
pub struct DisputePanel {
    pub dispute_id: u64,
    pub members: Vec<Pubkey>,
    pub weights: Vec<u16>,      // Voting weight for each member
    pub selection_seed: u64,    // Seed used for deterministic selection
    pub expires_at: i64,        // When panel expires
    pub total_votes_cast: u16,  // Track votes cast
    pub weighted_votes_cast: u32, // Track weighted votes cast
    pub bump: u8,
}

impl DisputePanel {
    pub const MAX_PANEL_SIZE: usize = 7;
    
    pub fn space() -> usize {
        8 + // discriminator
        8 + // dispute_id
        4 + (32 * Self::MAX_PANEL_SIZE) + // members (vec + items)
        4 + (2 * Self::MAX_PANEL_SIZE) + // weights (vec + items)
        8 + // selection_seed
        8 + // expires_at
        2 + // total_votes_cast
        4 + // weighted_votes_cast
        1 + // bump
        32  // padding
    }
    
    pub fn is_member(&self, member: &Pubkey) -> bool {
        self.members.contains(member)
    }
    
    pub fn get_member_weight(&self, member: &Pubkey) -> Option<u16> {
        self.members
            .iter()
            .position(|m| m == member)
            .map(|idx| self.weights[idx])
    }
}


//error.rs
use anchor_lang::prelude::*;

#[error_code]
pub enum DisputeError {
    #[msg("Invalid dispute state for this operation")]
    InvalidDisputeState,

    #[msg("Only panel members can vote")]
    NotPanelMember,

    #[msg("Panel member has already voted")]
    AlreadyVoted,

    #[msg("Dispute has expired")]
    DisputeExpired,

    #[msg("Invalid panel size")]
    InvalidPanelSize,

    #[msg("Quorum not reached")]
    QuorumNotReached,

    #[msg("Invalid parties - must have at least 2")]
    InvalidParties,

    #[msg("URI too long")]
    UriTooLong,

    #[msg("Panel already formed")]
    PanelAlreadyFormed,

    #[msg("Panel selection seed already used")]
    SeedAlreadyUsed,

    #[msg("Invalid judgment choice")]
    InvalidJudgmentChoice,

    #[msg("Judgment already executed")]
    JudgmentAlreadyExecuted,

    #[msg("Unauthorized: Only admin can perform this action")]
    Unauthorized,

    #[msg("Duplicate panel members not allowed")]
    DuplicatePanelMembers,

    #[msg("Arithmetic overflow")]
    ArithmeticOverflow,

    #[msg("Invalid vote record")]
    InvalidVoteRecord,

    #[msg("Vote count mismatch")]
    VoteMismatch,

    #[msg("Judgment already finalized")]
    JudgmentAlreadyFinalized,

    // ADD THESE NEW ERROR CODES
    #[msg("Invalid escrow account provided")]
    InvalidEscrowAccount,

    #[msg("Cannot cancel dispute in current state")]
    CannotCancel,

    #[msg("Only dispute opener can cancel before panel formation")]
    UnauthorizedCancel,

    #[msg("Invalid panel weights")]
    InvalidPanelWeights,
}

//events.rs
use crate::state::DisputeState;
use crate::state::JudgmentChoice;
use anchor_lang::prelude::*; // ADD THIS IMPORT

#[event]
pub struct DisputeOpened {
    pub id: u64,
    pub opened_by: Pubkey,
    pub parties: Vec<Pubkey>,
    pub uri: String,
    pub timestamp: i64,
}

#[event]
pub struct PanelFormed {
    pub dispute_id: u64,
    pub members: Vec<Pubkey>,
    pub panel_size: u16,
    pub required_quorum: u16,
    pub expires_at: i64,
}

#[event]
pub struct PanelVoteCast {
    pub dispute_id: u64,
    pub voter: Pubkey,
    pub choice: JudgmentChoice,
    pub weight: u16,
    pub timestamp: i64,
}

#[event]
pub struct DisputeJudged {
    pub dispute_id: u64,
    pub judgment: JudgmentChoice,
    pub total_votes: u16,
    pub weighted_votes: u32,
    pub timestamp: i64,
}

#[event]
pub struct DisputeExecuted {
    pub dispute_id: u64,
    pub judgment: JudgmentChoice,
    pub linked_escrow: Option<Pubkey>,
    pub timestamp: i64,
}

// ADD THIS NEW EVENT
#[event]
pub struct DisputeCanceled {
    pub dispute_id: u64,
    pub canceled_by: Pubkey,
    pub previous_state: DisputeState,
    pub timestamp: i64,
}


//lib.rs
use anchor_lang::prelude::*;

pub mod error;
pub mod events;
pub mod instructions;
pub mod state;

use instructions::*;

declare_id!("AdQN2jzFXvBSmfhwAdKtjouacDKGvMqMnPAayxfmsTYn");
pub const ESCROW_PROGRAM_ID: Pubkey = pubkey!("5WWu5uNgBwop6etUhEpbVAt88M2RdDvz9vKHsyBE3rZg");

#[program]
pub mod disputes {
    use super::*;

    /// Initialize the dispute counter and admin config (ONE TIME ONLY)
    pub fn init_counter(ctx: Context<InitCounter>) -> Result<()> {
        instructions::init_counter::handler(ctx)
    }

    pub fn open_dispute(
        ctx: Context<OpenDispute>,
        parties: Vec<Pubkey>,
        uri: String,
        linked_escrow: Option<Pubkey>,
    ) -> Result<()> {
        instructions::open_dispute::handler(ctx, parties, uri, linked_escrow)
    }

    pub fn form_panel(
        ctx: Context<FormPanel>,
        members: Vec<Pubkey>,
        selection_seed: u64,
        required_quorum: u16,
    ) -> Result<()> {
        instructions::form_panel::handler(ctx, members, selection_seed, required_quorum)
    }

    pub fn cast_panel_vote(ctx: Context<PanelVote>, choice: state::JudgmentChoice) -> Result<()> {
        instructions::panel_vote::handler(ctx, choice)
    }

    pub fn finalize_judgment<'info>(
        ctx: Context<'_, '_, 'info, 'info, FinalizeJudgment<'info>>,
    ) -> Result<()> {
        instructions::finalize_judgment::handler(ctx)
    }

    pub fn execute_judgment(ctx: Context<ExecuteJudgment>) -> Result<()> {
        instructions::execute_judgment::handler(ctx)
    }

    // ADD THIS NEW INSTRUCTION
    pub fn cancel_dispute(ctx: Context<CancelDispute>) -> Result<()> {
        instructions::cancel_dispute::handler(ctx)
    }
}


//cargo.toml
[package]
name = "disputes"
version = "0.1.0"
description = "Dispute resolution smart contract for FreelanceDao"
edition = "2021"

[lib]
crate-type = ["cdylib", "lib"]
name = "disputes"

[features]
anchor-debug = []
no-entrypoint = []
no-idl = []
no-log-ix-name = []
cpi = ["no-entrypoint"]
default = []
idl-build = ["anchor-lang/idl-build"]

[dependencies]
anchor-lang = { version = "0.31.1", features = ["init-if-needed"] }
